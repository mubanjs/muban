import{r as a,o as i,c as s,b as e,d as n,F as r,e as t,a as d}from"./app.7a437beb.js";import{_ as c}from"./plugin-vue_export-helper.21dcd24c.js";const h={},l=e("h1",{id:"reactivity",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#reactivity","aria-hidden":"true"},"#"),t(" Reactivity")],-1),u=e("p",null,[t("Instead of updating the DOM by hand after manually adding event listeners to manually queried elements, Muban makes used of the "),e("a",{href:""},"@vue/reactivity"),t(" package to - with the help of some additional utils and binding setup - create a single data flow from user input to DOM mutations, that take the component state as the focus.")],-1),p=e("p",null,"Good articles to read are:",-1),f={href:"https://v3.vuejs.org/guide/composition-api-introduction.html",target:"_blank",rel:"noopener noreferrer"},m=t("https://v3.vuejs.org/guide/composition-api-introduction.html"),g={href:"https://composition-api.vuejs.org/api.html",target:"_blank",rel:"noopener noreferrer"},b=t("https://composition-api.vuejs.org/api.html"),y=d('<p>It would also help to point out similarities and differences in how reactivity is used between Vue and Muban, since other parts of the component setup are a bit different.</p><h4 id="similarities" tabindex="-1"><a class="header-anchor" href="#similarities" aria-hidden="true">#</a> Similarities</h4><ul><li><p>Both Vue and Muban use a <code>setup</code> function to manage component state.</p></li><li><p>Component state is managed through <code>ref</code>, <code>reactive</code> and <code>computed</code>.</p></li><li><p>with the help of <code>watch</code> and <code>watchEffect</code> (from the <code>@vue/runtime-core</code> package) you can react to changes in the state, and trigger side-effects.</p></li><li><p>Both have lifecycle &quot;hooks&quot; (e.g. <code>onMounted</code>) that can be used in the <code>setup</code> function.</p></li><li><p>&quot;hooks&quot; or &quot;compositions&quot; are separate functions with reusable code that can be invoked in the <code>setup</code> function or other &quot;hooks&quot;, and can make use of both the reactive state and lifecycle hooks.</p></li><li><p>Incoming props are &quot;reactive&quot;, so they can be used in bindings or be watched, resulting in targeted DOM updates only to those affected elements.</p></li><li><p>State is used to define how the DOM should be displayed (although the methods are different).</p></li><li><p>Passing down reactive data between hooks or templates/bindings has the same caveats with destructuring and wrapping things in refs.</p></li></ul><h4 id="differences" tabindex="-1"><a class="header-anchor" href="#differences" aria-hidden="true">#</a> Differences</h4><ul><li><p><strong>Vue</strong> creates all elements in the template/JSX, while <strong>Muban</strong> only changes certain elements with bindings.</p></li><li><p>In <strong>Vue</strong> and <strong>React</strong>, because they render everything, the data/state flows from top to bottom. Your props always come from the parent.</p><p>In <strong>Muban</strong> the rendered HTML is your initial source of truth. Similar-ish to an SSR setup, the components need to &quot;re-hydrate&quot; their initial state based on the rendered HTML. This initial state is placed on the elements itself, being passed to / queried from (child) components directly. Which means that most initial data flows bottom-up from child to parent components.</p></li><li><p>In <strong>Vue</strong> and <strong>React</strong>, a <code>ref</code> is a boxed primitive you can assign directly to HTML tags with the <code>ref=</code> attribute.</p><p>In <strong>Muban</strong> you also have the <code>data-ref=</code> attribute, and have the same <code>ref</code> in your state, but they are not linked up. So the concept is the same, but the technical solution is slightly different. In Muban you define your refs in the component definition (that will query your <code>data-ref</code> elements), and they become &quot;ref items&quot; that can be used in bindings.</p></li></ul>',5);function _(v,w){const o=a("ExternalLinkIcon");return i(),s(r,null,[l,u,p,e("ul",null,[e("li",null,[e("a",f,[m,n(o)])]),e("li",null,[e("a",g,[b,n(o)])])]),y],64)}var M=c(h,[["render",_]]);export{M as default};
